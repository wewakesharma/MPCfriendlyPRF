//
// Created by Vivek Sharma on 1/18/21.
//

#include <iostream>
#include <cstdlib>
#include "packedMod2.hpp"
#include "packedMod3.hpp"
#include "mains.hpp"
#include "PRF.hpp"
#include "packed_PRF_central.h"
#include "OT.hpp"
#include "Timing.hpp"
#include <chrono>
#include "integer_pack.h"
#include "lookup_functions.h"

#ifdef TEST_INTEGER_PACKING

void set_inputs(std::vector<uint64_t>& K, PackedZ2<N_COLS>& x, std::vector<PackedZ3<81> >& Rmat)
{
    randomWord(1); // use seed=1
    for (auto &w : K) w = randomWord();
    K[K.size() - 1] &= topelitzMask; // turn off extra bits at the end
    x.randomize();
    for (auto &col : Rmat) // iterate over the columns
        col.randomize();
}

int main()  {

    long timer_int_packed_central = 0; //time the entire PRF computation nRuns times using integer packing
    long timer_int_pack_p2 = 0;
    long timer_int_matByVec = 0;


    PackedZ3<81> outZ3_dummy;

    int nRuns = 1000; //number of times the program runs

    std::cout<<"Running Packed PRF Centralized with integer packing for "<<nRuns<<" times."<<std::endl;
    /*
     * Code to determine the high point time precision of the machine
     */
    using Clock = std::chrono::system_clock;
    using Duration = Clock::duration;
    std::cout << Duration::period::num << " ==> " << Duration::period::den << '\n';

    //generate the inputs
    std::vector<uint64_t> K(toeplitzWords);//key shares of parties
    PackedZ2<N_COLS> x; //input shares of parties

    //generate a 81 X 256 randomization matrix in Z3.
    std::vector<PackedZ3<81> > Rmat(256);
    //reformating Rmat from 81 X 256 to 14 X 256
    std::vector<std::vector<uint64_t> > Rmat14(256);//outer vector is of size 256 and inner is of size 14

    PackedZ3<81> outZ3;//output by centralized computation
    PackedZ3<81> outZ3_int_pack;//output of integer packing

    //generate random inputs
    set_inputs(K,x,Rmat); //set random inputs for K, x and Rmat

#ifdef DEBUG
    for (int i = 0; i < 256; i++)
    {
        Rmat[i].reset();
    }
//    Rmat[0].set(0,1);
 //   Rmat[0].set(1,2);
 //   Rmat[0].set(0,2);
//    for (int j = 0; j < 80; j++) {
 //       Rmat[128].set(j, 2);
 //   }
    Rmat[128].set(0, 2);

    K= {0,0,1,0,0,0,0,0};
    X.reset();
    X.set(0,1);
//    X.set(1,1);
#endif

    //pack the Rmat
    pack_matrix(Rmat14,Rmat);   //pack (81 X 256) to (14 X 256)

#ifdef DEBUG
    for(int i = 0; i < 256; i++)
    {
        std::cout<<Rmat14[i] << std::endl;
    }
#endif

    for(unsigned int i = 0; i< nRuns;i++) {
        auto start_central_prf_p2 = std::chrono::system_clock::now();
        PackedZ2<N_COLS> outKX;
        outKX.toeplitzByVec(K,x);//perform K*X

        std::vector<unsigned int> outKX_unsgn;//unsigned int of outKX i.e.(K*x)
        outKX.toArray(outKX_unsgn);

        PackedZ3<256> outKX_Z3;//intermediate value of (K*X) packed Z3
        outKX_Z3.fromArray(outKX_unsgn);//converting unsigned int to PackedZ2
        timer_int_pack_p2 += (std::chrono::system_clock::now() - start_central_prf_p2).count();

        outZ3.matByVec(Rmat,outKX_Z3);//output of the centralized computation of PRF

        //perform matByVec and get the output.[K*x*Rmat]
        auto start_int_matByVec = std::chrono::system_clock::now();
        matByVec_int_pack(outZ3_int_pack,  outKX,  Rmat14); //matrix vector product using integer packing
        timer_int_matByVec += (std::chrono::system_clock::now() - start_int_matByVec).count();

        outZ3_dummy += outZ3_int_pack;//dummy variable for accurate timing.
    }
    std::cout<<std::endl<<"Output generated by packing is "<<outZ3_int_pack<<std::endl;

    if (outZ3_int_pack ==outZ3)
            std::cout<<"The test passed"<<std::endl;
    else
        std::cout<<"The test failed"<<std::endl;

    using Clock = std::chrono::system_clock;
    using Duration = Clock::duration;
    //std::cout << Duration::period::num << " , " << Duration::period::den << '\n';
    float time_unit_multiplier = 1;
    if(Duration::period::den == 1000000000)
        time_unit_multiplier = 0.001; //make nanosecond to microsecond
    else if(Duration::period::den == 1000000)
        time_unit_multiplier = 1;   //keep the unit as microsecond


    timer_int_packed_central = timer_int_pack_p2 + timer_int_matByVec;
    std::cout<<"Time for "<<nRuns<<" runs of running phase 1 & 2 of centralized "<<(timer_int_pack_p2 * time_unit_multiplier)<<" microseconds"<<std::endl;
    std::cout<<"Time for "<<nRuns<<" runs of running matByVec using Integer packing & unpacking "<<(timer_int_matByVec * time_unit_multiplier)<<" microseconds"<<std::endl;
    std::cout<<"Time for "<<nRuns<<" runs of entire PRF using integer packing "<<(timer_int_packed_central * time_unit_multiplier)<<" microseconds"<<std::endl;

    std::cout<<"Number of rounds per second for matByVec using Integer packing & unpacking "<<(1000/(timer_int_matByVec*time_unit_multiplier)*1000000)<<std::endl;
    std::cout<<"Number of rounds per second for running entire PRF using integer packing "<<(1000/(timer_int_packed_central*time_unit_multiplier)*1000000)<<std::endl;

}
#endif
